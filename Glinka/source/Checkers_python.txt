
from tkinter import *
import random
import time
import copy

win = Tk()
win.title('Шашки')
win.geometry('1000x800')
Board_canva = Canvas(win, width=800, height=800, bg='#FFFFFF')
Board_canva.place(x=0, y=0)

#Для счётчика и результатов
canvas_1 = Canvas(win, width=200, height=200, bg='#D3D3D3', highlightthickness=1)
canvas_1.place(x=800, y=0)


n2_spisok = ()  # конечный список ходов компьютера
ur = 3  # количество предсказываемых компьютером ходов
k_rez = 0  # !!!
o_rez = 0
poz1_x = -1  # клетка не задана
f_hi = True  # определение хода игрока(да)

# загружаем изображения пешек
def Sprite_game():
    global sprite_fig
    i0 = PhotoImage(file="res\\Board.png")     # фон(доска)
    i1 = PhotoImage(file="res\\White1.png")    # белая пешка
    i2 = PhotoImage(file="res\\White_dam.png") # белая дамка
    i3 = PhotoImage(file="res\\Black1.png")    # чёрная пешка
    i4 = PhotoImage(file="res\\Black_dam.png") # чёрная дамка

    sprite_fig = [i0, i1, i2, i3, i4]

# для глобальной переменной с расположением элементов на доске
def Game():
    global Board_array
    Board_array = [[0, 3, 0, 3, 0, 3, 0, 3],
                   [3, 0, 3, 0, 3, 0, 3, 0],
                   [0, 3, 0, 3, 0, 3, 0, 3],
                   [0, 0, 0, 0, 0, 0, 0, 0],
                   [0, 0, 0, 0, 0, 0, 0, 0],
                   [1, 0, 1, 0, 1, 0, 1, 0],
                   [0, 1, 0, 1, 0, 1, 0, 1],
                   [1, 0, 1, 0, 1, 0, 1, 0]]

# отрисовка фигур
def Draw(x_poz_1, y_poz_1, x_poz_2, y_poz_2):
    global sprite_fig
    global Board_array
    global kr_ramka, zel_ramka
    k = 100
    x = 0
    Board_canva.delete('all')
    Board_canva.create_image(0, 0, anchor=NW, image=sprite_fig[0])
    kr_ramka = Board_canva.create_rectangle(-5, -5, -5, -5, outline="red", width=5)
    zel_ramka = Board_canva.create_rectangle(-5, -5, -5, -5, outline="green", width=5)

    for y in range(8):
        for x in range(8):
            z = Board_array[y][x]
            if z:
                if (x_poz_1, y_poz_1) != (x, y):  # стоячие пешки?
                    Board_canva.create_image(x * k, y * k, anchor=NW, image=sprite_fig[z])
    # рисуем активную пешку
    z = Board_array[y_poz_1][x_poz_1]
    if z:
        Board_canva.create_image(x_poz_1 * k, y_poz_1 * k, anchor=NW, image=sprite_fig[z], tag='ani')

    # вычисление коэф. для анимации
    kx = 1 if x_poz_1 < x_poz_2 else -1
    ky = 1 if y_poz_1 < y_poz_2 else -1

    for i in range(abs(x_poz_1 - x_poz_2)):  # анимация перемещения пешки
        for ii in range(33):
            Board_canva.move('ani', 0.03 * k * kx, 0.03 * k * ky)
            Board_canva.update()  # обновление
            time.sleep(0.007)


def poz_1(event):  # выбор клетки для хода 1
    x, y = (event.x) // 100, (event.y) // 100  # вычисляем координаты клетки
    Board_canva.coords(zel_ramka, x * 100, y * 100, x * 100 + 100, y * 100 + 100)  # рамка в выбранной клетке


def poz_2(event):  # выбор клетки для хода 2
    global poz1_x, poz1_y, poz2_x, poz2_y
    global f_hi
    x, y = (event.x) // 100, (event.y) // 100  # вычисляем координаты клетки
    if Board_array[y][x] == 1 or Board_array[y][x] == 2:  # проверяем пешку игрока в выбранной клетке
        Board_canva.coords(kr_ramka, x * 100, y * 100, x * 100 + 100, y * 100 + 100)  # рамка в выбранной клетке
        poz1_x, poz1_y = x, y
    else:
        if poz1_x != -1:  # клетка выбрана
            poz2_x, poz2_y = x, y
            if f_hi:  # ход игрока?
                Player_move()
                if not (f_hi):
                    time.sleep(0.5)
                    hod_kompjutera()  # передаём ход компьютеру
                    # gl_okno.after(500,hod_kompjutera(0))#!!!#передаём ход компьютеру
            poz1_x = -1  # клетка не выбрана
            Board_canva.coords(kr_ramka, -5, -5, -5, -5)  # рамка вне поля


def hod_kompjutera():  # !!!
    global f_hi
    global n2_spisok
    proverka_hk(1, (), [])
    if n2_spisok:  # проверяем наличие доступных ходов
        kh = len(n2_spisok)  # количество ходов
        th = random.randint(0, kh - 1)  # случайный ход
        dh = len(n2_spisok[th])  # длина хода

        for i in range(dh - 1):
            # выполняем ход
            spisok = move(1, n2_spisok[th][i][0], n2_spisok[th][i][1], n2_spisok[th][1 + i][0], n2_spisok[th][1 + i][1])
        n2_spisok = []  # очищаем список ходов
        f_hi = True  # ход игрока доступен


def spisok_hk():  # составляем список ходов компьютера
    spisok = view_move_k1([])  # здесь проверяем обязательные ходы
    if not (spisok):
        spisok = view_move_k2([])  # здесь проверяем оставшиеся ходы
    return spisok


def proverka_hk(tur, n_spisok, spisok):  # !!!
    global Board_array
    global n2_spisok
    global l_rez, k_rez, o_rez
    if not (spisok):  # если список ходов пустой...
        spisok = spisok_hk()  # заполняем

    if spisok:
        k_pole = copy.deepcopy(Board_array)  # копируем поле
        for ((poz1_x, poz1_y), (poz2_x, poz2_y)) in spisok:  # проходим все ходы по списку
            t_spisok = move(0, poz1_x, poz1_y, poz2_x, poz2_y)
            if t_spisok:  # если существует ещё ход
                proverka_hk(tur, (n_spisok + ((poz1_x, poz1_y),)), t_spisok)
            else:
                proverka_hi(tur, [])
                if tur == 1:
                    t_rez = o_rez / k_rez
                    if not (n2_spisok):  # записыаем если пустой
                        n2_spisok = (n_spisok + ((poz1_x, poz1_y), (poz2_x, poz2_y)),)
                        l_rez = t_rez  # сохряняем наилучший результат
                    else:
                        if t_rez == l_rez:
                            n2_spisok = n2_spisok + (n_spisok + ((poz1_x, poz1_y), (poz2_x, poz2_y)),)
                        if t_rez > l_rez:
                            n2_spisok = ()
                            n2_spisok = (n_spisok + ((poz1_x, poz1_y), (poz2_x, poz2_y)),)
                            l_rez = t_rez  # сохряняем наилучший результат
                    o_rez = 0
                    k_rez = 0

            Board_array = copy.deepcopy(k_pole)  # возвращаем поле
    else:
        s_k, s_i = skan()  # подсчёт результата хода
        o_rez += (s_k - s_i)
        k_rez += 1


def spisok_hi():  # составляем список ходов игрока
    spisok = view_move_i1([])  # здесь проверяем обязательные ходы
    if not (spisok):
        spisok = view_move_i2([])  # здесь проверяем оставшиеся ходы
    return spisok


def proverka_hi(tur, spisok):
    global Board_array, k_rez, o_rez
    global ur
    if not (spisok):
        spisok = spisok_hi()

    if spisok:  # проверяем наличие доступных ходов
        k_pole = copy.deepcopy(Board_array)  # копируем поле
        for ((poz1_x, poz1_y), (poz2_x, poz2_y)) in spisok:
            t_spisok = move(0, poz1_x, poz1_y, poz2_x, poz2_y)
            if t_spisok:  # если существует ещё ход
                proverka_hi(tur, t_spisok)
            else:
                if tur < ur:
                    proverka_hk(tur + 1, (), [])
                else:
                    s_k, s_i = skan()  # подсчёт результата хода
                    o_rez += (s_k - s_i)
                    k_rez += 1

            Board_array = copy.deepcopy(k_pole)  # возвращаем поле
    else:  # доступных ходов нет
        s_k, s_i = skan()  # подсчёт результата хода
        o_rez += (s_k - s_i)
        k_rez += 1


def skan():  # подсчёт пешек на поле
    global Board_array
    s_i = 0
    s_k = 0
    for i in range(8):
        for ii in Board_array[i]:
            if ii == 1: s_i += 1
            if ii == 2: s_i += 3
            if ii == 3: s_k += 1
            if ii == 4: s_k += 3
    return s_k, s_i


def Player_move():
    global poz1_x, poz1_y, poz2_x, poz2_y
    global f_hi
    f_hi = False  # считаем ход игрока выполненным
    spisok = spisok_hi()
    if spisok:
        if ((poz1_x, poz1_y), (poz2_x, poz2_y)) in spisok:  # проверяем ход на соответствие правилам игры
            t_spisok = move(1, poz1_x, poz1_y, poz2_x, poz2_y)  # если всё хорошо, делаем ход
            if t_spisok:  # если есть ещё ход той же пешкой
                f_hi = True  # считаем ход игрока невыполненным
        else:
            f_hi = True  # считаем ход игрока невыполненным
    Board_canva.update()  # !!!обновление

#Действия фигурам(ход, битьё, превращение в дамки )  Проверка доступных ходов
def move(f, poz1_x, poz1_y, poz2_x, poz2_y):
    global Board_array
    if f: Draw(poz1_x, poz1_y, poz2_x, poz2_y)  # рисуем игровое поле
    # превращение в дамку
    if poz2_y == 0 and Board_array[poz1_y][poz1_x] == 1:
        Board_array[poz1_y][poz1_x] = 2
    # превращение в дамку
    if poz2_y == 7 and Board_array[poz1_y][poz1_x] == 3:
        Board_array[poz1_y][poz1_x] = 4
    # делаем ход
    Board_array[poz2_y][poz2_x] = Board_array[poz1_y][poz1_x]
    Board_array[poz1_y][poz1_x] = 0

    # рубим пешку игрока
    kx = ky = 1
    if poz1_x < poz2_x: kx = -1
    if poz1_y < poz2_y: ky = -1
    x_poz, y_poz = poz2_x, poz2_y
    while (poz1_x != x_poz) or (poz1_y != y_poz):
        x_poz += kx
        y_poz += ky
        if Board_array[y_poz][x_poz] != 0:
            Board_array[y_poz][x_poz] = 0
            if f: Draw(-1, -1, -1, -1)  # рисуем игровое поле
            # проверяем ход той же пешкой...
            if Board_array[poz2_y][poz2_x] == 3 or Board_array[poz2_y][poz2_x] == 4:  # ...компьютера
                return view_move_k1p([], poz2_x, poz2_y)  # возвращаем список доступных ходов
            elif Board_array[poz2_y][poz2_x] == 1 or Board_array[poz2_y][poz2_x] == 2:  # ...игрока
                return view_move_i1p([], poz2_x, poz2_y)  # возвращаем список доступных ходов
    if f: Draw(poz1_x, poz1_y, poz2_x, poz2_y)  # рисуем игровое поле

#Проверка наличия обязательных ходов
def view_move_k1(spisok):
    for y in range(8):  # сканируем всё поле
        for x in range(8):
            spisok = view_move_k1p(spisok, x, y)
    return spisok


def view_move_k1p(spisok, x, y):
    if Board_array[y][x] == 3:  # пешка
        for ix, iy in (-1, -1), (-1, 1), (1, -1), (1, 1):
            if 0 <= y + iy + iy <= 7 and 0 <= x + ix + ix <= 7:
                if Board_array[y + iy][x + ix] == 1 or Board_array[y + iy][x + ix] == 2:
                    if Board_array[y + iy + iy][x + ix + ix] == 0:
                        spisok.append(((x, y), (x + ix + ix, y + iy + iy)))  # запись хода в конец списка
    if Board_array[y][x] == 4:  # дамка
        for ix, iy in (-1, -1), (-1, 1), (1, -1), (1, 1):
            osh = 0  # определение правильности хода
            for i in range(1, 8):
                if 0 <= y + iy * i <= 7 and 0 <= x + ix * i <= 7:
                    if osh == 1:
                        spisok.append(((x, y), (x + ix * i, y + iy * i)))  # запись хода в конец списка
                    if Board_array[y + iy * i][x + ix * i] == 1 or Board_array[y + iy * i][x + ix * i] == 2:
                        osh += 1
                    if Board_array[y + iy * i][x + ix * i] == 3 or Board_array[y + iy * i][x + ix * i] == 4 or osh == 2:
                        if osh > 0: spisok.pop()  # удаление хода из списка
                        break
    return spisok

 # проверка наличия остальных ходов
def view_move_k2(spisok):
    for y in range(8):  # сканируем всё поле
        for x in range(8):
            if Board_array[y][x] == 3:  # пешка
                for ix, iy in (-1, 1), (1, 1):
                    if 0 <= y + iy <= 7 and 0 <= x + ix <= 7:
                        if Board_array[y + iy][x + ix] == 0:
                            spisok.append(((x, y), (x + ix, y + iy)))  # запись хода в конец списка
                        if Board_array[y + iy][x + ix] == 1 or Board_array[y + iy][x + ix] == 2:
                            if 0 <= y + iy * 2 <= 7 and 0 <= x + ix * 2 <= 7:
                                if Board_array[y + iy * 2][x + ix * 2] == 0:
                                    spisok.append(((x, y), (
                                    x + ix * 2, y + iy * 2)))  # запись хода в конец списка
            if Board_array[y][x] == 4:  # Дамка
                for ix, iy in (-1, -1), (-1, 1), (1, -1), (1, 1):
                    osh = 0  # определение правильности хода
                    for i in range(1, 8):
                        if 0 <= y + iy * i <= 7 and 0 <= x + ix * i <= 7:
                            if Board_array[y + iy * i][x + ix * i] == 0:
                                spisok.append(((x, y), (x + ix * i, y + iy * i)))  # запись хода в конец списка
                            if Board_array[y + iy * i][x + ix * i] == 1 or Board_array[y + iy * i][x + ix * i] == 2:
                                osh += 1
                            if Board_array[y + iy * i][x + ix * i] == 3 or Board_array[y + iy * i][x + ix * i] == 4 or osh == 2:
                                break
    return spisok

# проверка наличия обязательных ходов
def view_move_i1(spisok):
    spisok = []  # список ходов
    for y in range(8):  # сканируем всё поле
        for x in range(8):
            spisok = view_move_i1p(spisok, x, y)
    return spisok

def view_move_i1p(spisok, x, y):
    if Board_array[y][x] == 1:  # пешка
        for ix, iy in (-1, -1), (-1, 1), (1, -1), (1, 1):
            if 0 <= y + iy + iy <= 7 and 0 <= x + ix + ix <= 7:
                if Board_array[y + iy][x + ix] == 3 or Board_array[y + iy][x + ix] == 4:
                    if Board_array[y + iy + iy][x + ix + ix] == 0:
                        spisok.append(((x, y), (x + ix + ix, y + iy + iy)))  # запись хода в конец списка
    if Board_array[y][x] == 2:  # Дамка
        for ix, iy in (-1, -1), (-1, 1), (1, -1), (1, 1):
            osh = 0  # определение правильности хода
            for i in range(1, 8):
                if 0 <= y + iy * i <= 7 and 0 <= x + ix * i <= 7:
                    if osh == 1:
                        spisok.append(((x, y), (x + ix * i, y + iy * i)))  # запись хода в конец списка
                    if Board_array[y + iy * i][x + ix * i] == 3 or Board_array[y + iy * i][x + ix * i] == 4:
                        osh += 1
                    if Board_array[y + iy * i][x + ix * i] == 1 or Board_array[y + iy * i][x + ix * i] == 2 or osh == 2:
                        if osh > 0: spisok.pop()  # удаление хода из списка
                        break
    return spisok

# проверка наличия остальных ходов для компьютера
def view_move_i2(spisok):
    for y in range(8):  # сканируем всё поле
        for x in range(8):
            if Board_array[y][x] == 1:  # пешка
                for ix, iy in (-1, -1), (1, -1):
                    if 0 <= y + iy <= 7 and 0 <= x + ix <= 7:
                        if Board_array[y + iy][x + ix] == 0:
                            spisok.append(((x, y), (x + ix, y + iy)))  # запись хода в конец списка
                        if Board_array[y + iy][x + ix] == 3 or Board_array[y + iy][x + ix] == 4:
                            if 0 <= y + iy * 2 <= 7 and 0 <= x + ix * 2 <= 7:
                                if Board_array[y + iy * 2][x + ix * 2] == 0:
                                    spisok.append(((x, y), (
                                    x + ix * 2, y + iy * 2)))  # запись хода в конец списка
            if Board_array[y][x] == 2:  # пешка с короной
                for ix, iy in (-1, -1), (-1, 1), (1, -1), (1, 1):
                    osh = 0  # определение правильности хода
                    for i in range(1, 8):
                        if 0 <= y + iy * i <= 7 and 0 <= x + ix * i <= 7:
                            if Board_array[y + iy * i][x + ix * i] == 0:
                                spisok.append(((x, y), (x + ix * i, y + iy * i)))  # запись хода в конец списка
                            if Board_array[y + iy * i][x + ix * i] == 3 or Board_array[y + iy * i][x + ix * i] == 4:
                                osh += 1
                            if Board_array[y + iy * i][x + ix * i] == 1 or Board_array[y + iy * i][x + ix * i] == 2 or osh == 2:
                                break
    return spisok

Sprite_game()  # здесь загружаем изображения пешек
Game()  # начинаем новую игру
Draw(-1, -1, -1, -1)  # рисуем игровое поле
Board_canva.bind("<Motion>", poz_1)  # движение мышки по полю
Board_canva.bind("<Button-1>", poz_2)  # нажатие левой кнопки

mainloop()